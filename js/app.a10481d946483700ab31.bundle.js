(self.webpackChunk=self.webpackChunk||[]).push([[143],{138:(e,t,s)=>{const o=s(809),{lightningChart:a,emptyFill:r,emptyLine:l,AxisTickStrategies:n,AutoCursorModes:i,SolidFill:c,ColorRGBA:u,translatePoint:d,UILayoutBuilders:g,UIElementBuilders:m,UIOrigins:h,synchronizeAxisIntervals:f,Themes:x}=o,{createProgressiveTraceGenerator:S}=s(27),p=["Ch 1","Ch 2","Ch 3"],y=p.length,T=a().Dashboard({numberOfRows:y,numberOfColumns:1}),k=p.map(((e,t)=>{const s=T.createChartXY({columnIndex:0,rowIndex:t,columnSpan:1,rowSpan:1});return s.setAutoCursorMode(i.disabled),0===t?s.setTitle("Stacked Y Dashboard with Custom Cursor"):s.setTitleFillStyle(r),t!==y-1&&s.getDefaultAxisX().setTickStrategy(n.Empty),s.getDefaultAxisY().setThickness(50),s})),A=k[k.length-1].getDefaultAxisX(),E=k.map(((e,t)=>e.addLineSeries({dataPattern:{pattern:"ProgressiveX"}})));E.forEach(((e,t)=>S().setNumberOfPoints(1e5).generate().toPromise().then((t=>{e.add(t)})))),f(...k.map((e=>e.getDefaultAxisX())));const C=T.addUIElement(g.Column,T.engine.scale).setMouseInteractions(!1).setOrigin(h.LeftBottom).setMargin(5).setBackground((e=>e.setFillStyle(T.getTheme().resultTableFillStyle).setStrokeStyle(T.getTheme().resultTableStrokeStyle))),D=m.TextBox.addStyler((e=>e.setTextFillStyle(T.getTheme().resultTableTextFillStyle))),b=C.addElement(g.Row).addElement(D),B=E.map(((e,t)=>C.addElement(g.Row).addElement(D))),I=k[y-1].getDefaultAxisX().addCustomTick().setAllocatesAxisSpace(!1),X=[];k.forEach(((e,t)=>{t!==y-1&&X.push(e.getDefaultAxisX().addConstantLine().setValue(0).setMouseInteractions(!1).setStrokeStyle(e.getTheme().customTickGridStrokeStyle))}));const v=E.map(((e,t)=>k[t].getDefaultAxisY().addCustomTick().setAllocatesAxisSpace(!1))),M=e=>{e?(C.restore(),I.restore(),v.forEach((e=>e.restore())),X.forEach((e=>e.restore()))):(C.dispose(),I.dispose(),v.forEach((e=>e.dispose())),X.forEach((e=>e.dispose())))};M(!1),k.forEach(((e,t)=>{const s=e.getDefaultAxisX();e.onSeriesBackgroundMouseMove(((o,a)=>{const r={x:a.clientX,y:a.clientY},l=e.engine.clientLocation2Engine(r.x,r.y),n=E.map((e=>e.solveNearestFromScreen(l)));if(n.includes(void 0))return void M(!1);const i=n[t].location,c=d(i,E[t].scale,T.engine.scale);C.setPosition({x:c.x,y:l.y}),i.x>s.getInterval().end/1.5?C.setOrigin(h.RightBottom):C.setOrigin(h.LeftBottom),b.setText(`X: ${A.formatValue(n[t].location.x)}`),B.forEach(((e,t)=>{e.setText(`Y${t}: ${k[t].getDefaultAxisY().formatValue(n[t].location.y)}`)})),I.setValue(n[t].location.x),X.forEach(((e,t)=>{e.setValue(I.getValue())})),v.forEach(((e,t)=>{e.setValue(n[t].location.y)})),M(!0)})),e.onSeriesBackgroundMouseLeave(((e,t)=>{M(!1)})),e.onSeriesBackgroundMouseDragStart(((e,t)=>{M(!1)}))}))}},e=>{e.O(0,[736],(()=>(138,e(e.s=138)))),e.O()}]);